---
title: "Djamaldbz - Cr√©e ton assistant virtuel en python !!!"
author: "Djamal TOE"
date: "March 10, 2025"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE)
library(reticulate)
use_python("C:/Users/Djamal TOE/AppData/Local/Programs/Python/Python311")
```


# Introduction

|       Ce document explique en d√©tail le fonctionnement du code Python du Voxa Assistant, un assistant vocal interactif utilisant plusieurs biblioth√®ques pour la reconnaissance vocale, la synth√®se vocale et les requ√™tes en ligne. J'utilise en particulier **Wolfram Alpha**.


## Wolfram Alpha : C'est quoi et √† quoi √ßa sert ?

**Wolfram Alpha** est un moteur de calcul et de r√©ponse bas√© sur l'intelligence artificielle et les algorithmes symboliques. Contrairement √† un moteur de recherche classique comme Google, qui fournit des liens vers des sites web, **Wolfram Alpha g√©n√®re directement des r√©ponses pr√©cises bas√©es sur des bases de connaissances et des algorithmes math√©matiques avanc√©s**. Il est souvent utilis√© pour des calculs, des questions scientifiques et des recherches bas√©es sur des donn√©es structur√©es.

#### Utilit√© :

- R√©solution d'√©quations math√©matiques et scientifiques  
- Recherche et analyse de donn√©es (statistiques, physique, chimie, finance, etc.)  
- Interpr√©tation de requ√™tes en langage naturel  
- G√©n√©ration de graphiques et de simulations  

üîó **Cr√©er un compte Wolfram Alpha** :  
Si vous souhaitez utiliser l'API de Wolfram Alpha dans votre projet, vous devez cr√©er un compte via ce lien :  
üëâ [Cr√©er un compte Wolfram Alpha](https://www.wolframalpha.com/)
Je posterai une demo sur comment creer son compte et recup√©rer un id pour une application. Car en effet, il existe plusieurs type d'ID qui servent √† diff√©rentes type d'applications. Il fonctionne en Anglais donc nous allons √©crire une fonction pour la traduction du Francais en Anglais afin de poser des questions et une pour la traduction de l'Anglais en Fran√ßais pour la reponse trouv√©e. Vous avez bien entendu besoin de connexion pour effectuer les recherches. 

> ‚ö†Ô∏è **MISE √Ä JOUR IMPORTANTE DE L'API WOLFRAMALPHA ‚Äì 24 JUIN 2024**
>
> Depuis le **24 juin 2024**, **l'API WolframAlpha a chang√©**.  
> **L'ancienne m√©thode avec `Client.query()` et `next(response.results)` n'est plus fiable** et peut g√©n√©rer des erreurs (`StopIteration`, `TypeError`, etc.).
>
> ---
>
> ### ‚úÖ Nouvelle m√©thode recommand√©e :
> Utilisez l'API REST `v2/query` directement via `requests` :
>
> ```python
> import requests
> import xml.etree.ElementTree as ET
>
> def wolfram_query(query):
>     url = "https://api.wolframalpha.com/v2/query"
>     params = {
>         "appid": APP_ID,
>         "input": query,
>         "format": "plaintext"
>     }
>     response = requests.get(url, params=params)
>     root = ET.fromstring(response.content)
>     pods = root.findall('.//pod')
>
>     for pod in pods:
>         title = pod.attrib.get('title', '').lower()
>         if any(kw in title for kw in ['result', 'definition', 'primary']):
>             txt = pod.find('.//plaintext')
>             if txt is not None and txt.text:
>                 return txt.text
>     return "Aucune r√©ponse trouv√©e."
> ```
>
> ---
>
> üéôÔ∏è **Et pour les commandes vocales ?**  
> Traduisez votre question en anglais avant l'envoi (`translate_fr_en`) et traduisez la r√©ponse inversement pour l'afficher ou la vocaliser (`translate_en_fr`).
>
> üí° **Exemple vocal** :  
> Dites **‚ÄúInt√©grale de ln(x)‚Äù** ‚Üí traduit en **"integrate ln(x)"** ‚Üí r√©ponse trait√©e par l‚ÄôAPI.


**Exemple d'utilisation**

```{python, echo= FALSE, eval=TRUE}
id_ = "G74XUU-L67284UYJQ"
```


```{python, echo = TRUE, eval= TRUE}
import wolframalpha
# id_ = "YOUR_WOLFRAMALPHA_ID"
##-- J'utliserai le mien que j'ai masqu√©
# id_ = r.id_
client = wolframalpha.Client(id_)
queries = [
  "who is the president of France",
  "compute 2 times 2 times ln(2)",
  "derivate xln(x)",
  "integrate exponential of 2x between 2 and 4"
]
# print(id_)
```


```{python}
import requests
import xml.etree.ElementTree as ET

def wolfram_query(query):
    """
    Interroge l'API WolframAlpha avec une requ√™te textuelle et extrait la r√©ponse principale.

    Param√®tres :
    -----------
    query : str
        La question ou l'expression math√©matique √† envoyer √† WolframAlpha.

    Retour :
    --------
    str ou None
        Le texte de la r√©ponse principale si trouv√©e, sinon None.
    
    Fonctionnement :
    ----------------
    - Envoie la requ√™te √† l'API WolframAlpha (format XML).
    - V√©rifie que la r√©ponse est bien en XML.
    - Parse le XML pour extraire les 'pods' (blocs de r√©ponses).
    - Recherche prioritairement un pod dont le titre contient 'result', 'definition' ou 'primary'.
    - Sinon retourne le premier pod contenant du texte.
    - Si aucune r√©ponse trouv√©e, retourne None.
    """

    # URL de l'API WolframAlpha pour requ√™tes de type 'query'
    url = "https://api.wolframalpha.com/v2/query"

    # Param√®tres envoy√©s : cl√© API, la question, format de r√©ponse demand√© (texte brut)
    params = {
        "appid": id_,
        "input": query,
        "format": "plaintext"
    }

    # Envoi de la requ√™te HTTP GET
    response = requests.get(url, params=params)

    # V√©rification que la r√©ponse est bien du XML
    content_type = response.headers.get('Content-Type', '')
    if 'xml' not in content_type:
        raise ValueError(f"Format inattendu : {content_type}")

    # Parsing du contenu XML de la r√©ponse
    root = ET.fromstring(response.content)

    # Recherche de tous les pods (sections de r√©ponse)
    pods = root.findall('.//pod')

    # Premi√®re passe : chercher un pod contenant la r√©ponse principale
    for pod in pods:
        title = pod.attrib.get('title', '').lower()
        if 'result' in title or 'definition' in title or 'primary' in title:
            plaintext = pod.find('.//plaintext')
            if plaintext is not None and plaintext.text:
                print(f"R√©ponse pour '{query}' : {plaintext.text}")
                return plaintext.text

    # Seconde passe : si pas de pod "r√©sultat", afficher le premier pod avec du texte
    for pod in pods:
        plaintext = pod.find('.//plaintext')
        if plaintext is not None and plaintext.text:
            print(f"R√©ponse pour '{query}' : {plaintext.text}")
            return plaintext.text

    # Si aucun pod avec texte, afficher message d'erreur
    print(f"Aucune r√©ponse trouv√©e pour '{query}'")
    return None
```



```{python}
wolfram_query(queries[0])
```

```{python}
wolfram_query(queries[1])
```

```{python}
wolfram_query(queries[2])
```

```{python}
wolfram_query(queries[3])
```

### Explication des parties techniques de votre code

Le script commence par l'importation des biblioth√®ques n√©cessaires :

```{python, eval = TRUE}
import datetime
import webbrowser
import sys
import pywhatkit
import speech_recognition as sr
import pyttsx3 as ttx
import wikipedia
from googletrans import Translator
import wolframalpha
```

- `datetime` : gestion des dates et heures.
- `webbrowser` : ouverture des pages web.
- `sys` : gestion des fonctionnalit√©s syst√®me.
- `pywhatkit` : ex√©cution de commandes interactives comme la recherche YouTube.
- `speech_recognition` : reconnaissance vocale.
- `pyttsx3` : synth√®se vocale.
- `wikipedia` : r√©cup√©ration d'informations depuis Wikip√©dia.
- `googletrans` : traduction de texte.
- `wolframalpha` : moteur de r√©ponse √† des questions scientifiques et math√©matiques.

Intaller les avec la commande :

```{python}
modules = [
    "pywhatkit", "speechrecognition", "pyttsx3",
    "wikipedia", "googletrans==4.0.0-rc1", "wolframalpha", "pyaudio"
]

import subprocess
import sys
def install_modules():
    for module in modules:
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", module])
        except:
            print("Quelque chose s'est mal pass√©e")
            
install_modules()
```


## 2. Configuration du moteur de synth√®se vocale

Le code initialise `pyttsx3` et affiche les voix disponibles :

```{python}
moteur = ttx.init()
voix_disponibles = moteur.getProperty("voices")

for index, voix in enumerate(voix_disponibles):
    print(f"Index {index} - ID: {voix.id} - Langue: {voix.languages} - Nom: {voix.name}")
```

Ensuite, une voix sp√©cifique est s√©lectionn√©e et test√©e :

```{python}
moteur.setProperty("voice", voix_disponibles[2].id)
moteur.say("Bonjour, ceci est un test avec une autre voix.")
moteur.runAndWait()
```

## 3. D√©finition de la classe `voxaAssistant`
La classe `voxaAssistant` g√®re toutes les fonctionnalit√©s de l'assistant vocal.

### 3.1 Initialisation

```{python}
class voxaAssistant:
    def __init__(self):
        self.ecouteur = sr.Recognizer()
        self.moteur = ttx.init()
        self.voix_disponibles = self.moteur.getProperty("voices")
        self.moteur.setProperty("voice", self.voix_disponibles[2].id)
        self.moteur.setProperty("rate", 170)
        self.app_id = id_
        self.client = wolframalpha.Client(self.app_id)
```

Cette m√©thode :
- Initialise le moteur de reconnaissance vocale (`speech_recognition`)

- Configure la synth√®se vocale avec `pyttsx3`

- D√©finit la cl√© API pour Wolfram Alpha.

### 3.2 Fonction `parler`

Cette fonction g√©n√®re une sortie vocale √† partir d'un texte donn√©.

```{python}
def parler(self, texte):
    self.moteur.say(texte)
    self.moteur.runAndWait()
```

### 3.3 Fonction `saluer`

Cette fonction ajuste le message de salutation en fonction de l'heure.

```{python}
def saluer(self):
    heure_actuel = int(datetime.datetime.now().hour)
    if 0 <= heure_actuel <= 12:
        self.parler("Bonjour √† vous Djamal")
    else:
        self.parler("Bonsoir √† vous Djamal")
```

## 4. Reconnaissance et Traitement des Requ√™tes Vocales

### Fonction `voxa_requete`

Cette fonction √©coute l'utilisateur et transcrit la parole en texte.

```{python}
def voxa_requete(self):
    with sr.Microphone() as parole:
        print("Entrain d'√©couter ...")
        self.ecouteur.adjust_for_ambient_noise(parole, duration=1)
        self.ecouteur.pause_threshold = 1.5
        try:
            voix = self.ecouteur.listen(parole, timeout=5, phrase_time_limit=5)
            command = self.ecouteur.recognize_google(voix, language="fr").lower()
            print("Vous avez dit .... : ", command)
            return command
        except sr.UnknownValueError:
            print("Je n'ai pas compris, veuillez r√©p√©ter.")
            return ""
        except sr.RequestError:
            print("Erreur avec le service de reconnaissance vocale.")
            return ""
```

### Recherche Google et YouTube

Si l'utilisateur mentionne `Google` ou `YouTube`, la recherche est effectu√©e automatiquement.

```{python, eval = FALSE}
elif "google" in voix:
    url = voix.split().index("google")
    elt_rechercher = voix.split()[url + 1:]
    self.parler("D'accord, je lance la recherche")
    webbrowser.open("https://www.google.com/search?q=" + "+".join(elt_rechercher), new=2)
```

```{python, eval = FALSE}
elif "recherche sur youtube" in voix or "recherche sur youtube.com" in voix:
                url = voix.split().index("youtube")
                elt_rechercher = voix.split()[url + 1:]
                self.parler("d'accord  je  lance  la  recherche")
                webbrowser.open(
                    "http://www.youtube.com/results?search_query="
                    + "+".join(elt_rechercher),
                    new=2,
                )
```


#### **1Ô∏è‚É£ `split()` : Pourquoi l'utiliser ici ?**

```{python, eval = FALSE}
url = voix.split().index("google")
elt_rechercher = voix.split()[url + 1:]
```

- **`split()`** d√©coupe une cha√Æne de caract√®res en une liste de mots.
- Ici, on cherche l'index du mot **"google"** pour r√©cup√©rer les mots suivants, qui correspondent √† la requ√™te de l'utilisateur.  
- **Exemple :**  
  - **Entr√©e** : `"cherche sur google c'est quoi la capitale de la France"`  
  - **Apr√®s split()** : `["cherche","sur", "google", "c", "'", "est", "quoi", "la", "capitale", "de", "la", "France"]`  
  - **Index du mot "google"** : `3`  
  - **Ce qui est recherch√©** : `["c", "'", "est", "quoi", "la", "capitale", "de", "la", "France"]` ‚Üí Ici, on devrait prendre les mots apr√®s **"google"**.
  
#### 2Ô∏è‚É£ Pourquoi y a-t-il des `+` dans l'URL de Google et YouTube ?


```{python, eval = FALSE}
webbrowser.open("https://www.google.com/search?q=" + "+".join(elt_rechercher), new=2)
```
  

```{python, eval = FALSE}
elif "youtube" in voix:
    s = voix.replace("youtube", "")
    self.parler("D'accord sans soucis")
    pywhatkit.playonyt(s)
```

- **Explication du `+`.**  
  - Dans une URL, un **espace** est souvent remplac√© par **`+` ou `%20`**.  
  - **Exemple** : Si l'utilisateur dit *"recherche machine learning sur google"*, on doit transformer `"machine learning"` en `"machine+learning"` pour que Google comprenne.  
  - **Autre solution** : `"%20".join(elt_rechercher)` aurait aussi pu √™tre utilis√©. 
  
### Recherches Avanc√©es avec Wolfram Alpha et Wikip√©dia

#### Utilisation de Wolfram Alpha pour r√©pondre aux questions g√©n√©rales

```{python, eval = FALSE}
    def question_generale(self, voix):
        voix = self.translate_eng_fr(voix)
        try:
            reponse = self.client.query(voix)
            res = next(reponse.results).text
            res = self.translate_fr_eng(res)
            print("Un instant ...")
            print(res)
            self.parler(res)
        except:
            self.parler("Je n'ai pas trouv√© de r√©ponse.")
```

|       Ici, l'assistant vocal envoie la requ√™te √† Wolfram Alpha, r√©cup√®re la r√©ponse et la traduit en fran√ßais avant de la prononcer.
Si aucune r√©ponse n'est trouv√©e, une recherche est effectu√©e sur Wikip√©dia.

#### Utilisation de wikipedia pour r√©pondre aux questions g√©n√©rales

```{python, eval=FALSE}
try:
    wikipedia.set_lang("fr")
    info = wikipedia.summary(voix, 1)
    self.parler(str(info))
except:
    self.parler("Je n'ai pas bien compris")
```


#### 3Ô∏è‚É£ `query` : √Ä quoi √ßa sert dans Wolfram Alpha*

```{python, eval=FALSE}
reponse = self.client.query(voix)
res = next(reponse.results).text
```

- **`.query(voix)`** : envoie la question de l'utilisateur √† Wolfram Alpha.  
- **`next(reponse.results).text`** : r√©cup√®re la premi√®re r√©ponse retourn√©e et extrait le texte.  
- **Si Wolfram Alpha trouve une r√©ponse pertinente, elle est lue √† haute voix.** 


### **R√©sum√© des concepts cl√©s :**
| √âl√©ment | Explication |
|---------|------------|
| **Wolfram Alpha** | Moteur de calcul intelligent r√©pondant √† des requ√™tes scientifiques et analytiques |
| **split()** | D√©coupe une phrase en liste de mots |
| **query()** | Envoie une requ√™te √† Wolfram Alpha |
| **join("+")** | Transforme une liste de mots en requ√™te lisible par un moteur de recherche |

# Code complet pour l'assistant virtuel

```{.python, eval = FALSE}
import requests
import xml.etree.ElementTree as ET
import datetime
import webbrowser
import sys
import pywhatkit
import speech_recognition as sr
import pyttsx3 as ttx
import wikipedia
from googletrans import Translator
import wolframalpha

import pyttsx3

id_ = "YOUR-ID-WOLFRAMALPHA"


def wolfram_query(query):
    """
    Interroge l'API WolframAlpha avec une requ√™te textuelle et extrait la r√©ponse principale.

    Param√®tres :
    -----------
    query : str
        La question ou l'expression math√©matique √† envoyer √† WolframAlpha.

    Retour :
    --------
    str ou None
        Le texte de la r√©ponse principale si trouv√©e, sinon None.
    
    Fonctionnement :
    ----------------
    - Envoie la requ√™te √† l'API WolframAlpha (format XML).
    - V√©rifie que la r√©ponse est bien en XML.
    - Parse le XML pour extraire les 'pods' (blocs de r√©ponses).
    - Recherche prioritairement un pod dont le titre contient 'result', 'definition' ou 'primary'.
    - Sinon retourne le premier pod contenant du texte.
    - Si aucune r√©ponse trouv√©e, retourne None.
    """

    # URL de l'API WolframAlpha pour requ√™tes de type 'query'
    url = "https://api.wolframalpha.com/v2/query"

    # Param√®tres envoy√©s : cl√© API, la question, format de r√©ponse demand√© (texte brut)
    params = {
        "appid": APP_ID,
        "input": query,
        "format": "plaintext"
    }

    # Envoi de la requ√™te HTTP GET
    response = requests.get(url, params=params)

    # V√©rification que la r√©ponse est bien du XML
    content_type = response.headers.get('Content-Type', '')
    if 'xml' not in content_type:
        raise ValueError(f"Format inattendu : {content_type}")

    # Parsing du contenu XML de la r√©ponse
    root = ET.fromstring(response.content)

    # Recherche de tous les pods (sections de r√©ponse)
    pods = root.findall('.//pod')

    # Premi√®re passe : chercher un pod contenant la r√©ponse principale
    for pod in pods:
        title = pod.attrib.get('title', '').lower()
        if 'result' in title or 'definition' in title or 'primary' in title:
            plaintext = pod.find('.//plaintext')
            if plaintext is not None and plaintext.text:
                print(f"R√©ponse pour '{query}' : {plaintext.text}")
                return plaintext.text

    # Seconde passe : si pas de pod "r√©sultat", afficher le premier pod avec du texte
    for pod in pods:
        plaintext = pod.find('.//plaintext')
        if plaintext is not None and plaintext.text:
            print(f"R√©ponse pour '{query}' : {plaintext.text}")
            return plaintext.text

    # Si aucun pod avec texte, afficher message d'erreur
    print(f"Aucune r√©ponse trouv√©e pour '{query}'")
    return None


moteur = pyttsx3.init()

# R√©cup√©ration des voix disponibles
voix_disponibles = moteur.getProperty("voices")

# Affichage des identifiants des voix disponibles
for index, voix in enumerate(voix_disponibles):
    print(
        f"Index {index} - ID: {voix.id} - Langue: {voix.languages} - Nom: {voix.name}"
    )

# S√©lection d'une voix sp√©cifique (par exemple, la deuxi√®me voix)
moteur.setProperty(
    "voice", voix_disponibles[2].id
)  # Modifier l'index selon la voix souhait√©e

# Test de la nouvelle voix
moteur.say("Bonjour, ceci est un test avec une autre voix.")
moteur.runAndWait()


class voxaAssistant:
    def __init__(self):
        self.ecouteur = sr.Recognizer()
        self.moteur = ttx.init()
        self.voix_disponibles = self.moteur.getProperty("voices")
        self.moteur.setProperty("voice", self.voix_disponibles[2].id)
        self.moteur.setProperty("rate", 170)
        self.app_id = id_
        self.client = wolframalpha.Client(self.app_id)

    def parler(self, texte):
        self.moteur.say(texte)
        self.moteur.runAndWait()

    def saluer(self):
        heure_actuel = int(datetime.datetime.now().hour)
        if 0 <= heure_actuel <= 12:
            self.parler("Bonjour √† vous Djamal")
        else:
            self.parler("Bonsoir √† vous Djamal")

    def voxa_requete(self):
        with sr.Microphone() as parole:
            print("Entrain d'√©couter ...")
            self.ecouteur.adjust_for_ambient_noise(parole, duration=1)
            self.ecouteur.pause_threshold = 1.5
            try:
                voix = self.ecouteur.listen(parole, timeout=5, phrase_time_limit=5)
                command = self.ecouteur.recognize_google(voix, language="fr").lower()
                print("Vous avez dit .... : ", command)
                return command
            except sr.UnknownValueError:
                print("Je n'ai pas compris, veuillez r√©p√©ter.")
                return ""
            except sr.RequestError:
                print("Erreur avec le service de reconnaissance vocale.")
                return ""

    def translate_eng_fr(self, texte):
        translator = Translator()
        t = translator.translate(texte, src="fr", dest="en")
        return t.text

    def translate_fr_eng(self, texte):
        translator = Translator()
        t = translator.translate(texte, src="en", dest="fr")
        return t.text

    def question_generale(self, voix):
      voix_en = self.translate_eng_fr(voix)
      reponse = wolfram_query(voix_en)
      if reponse:
          res_fr = self.translate_fr_eng(reponse)
          print("Un instant ...")
          print(res_fr)
          self.parler(res_fr)
      else:
          self.parler("Je n'ai pas trouv√© de r√©ponse.")

    def voxa(self):
        voix = self.voxa_requete()
        if voix:
            if "arretes-toi" in voix or "arr√™te-toi" in voix:
                self.parler("Merci, ca a √©t√© un r√©el plaisir de vous avoir aid√©")
                sys.exit()
            elif "recherche sur youtube" in voix or "recherche sur youtube.com" in voix:
                url = voix.split().index("youtube")
                elt_rechercher = voix.split()[url + 1:]
                self.parler("d'accord  je  lance  la  recherche")
                webbrowser.open(
                    "http://www.youtube.com/results?search_query="
                    + "+".join(elt_rechercher),
                    new=2,
                )
            elif (
                "google" in voix
                or "recherche sur google" in voix
                or "sur google" in voix
            ):
                url = voix.split().index("google")
                elt_rechercher = voix.split()[url + 1:]
                self.parler("d'accord  je  lance  la  recherche")
                webbrowser.open(
                    "https://www.google.com/search?q=" + "+".join(elt_rechercher), new=2
                )
                self.parler("voici  ce  que  jai  trouv√©  sur  google ")
            elif "youtube" in voix:
                s = voix.replace("youtube", "")
                self.parler("D'accord sans soucis")
                pywhatkit.playonyt(s)
            elif "r√©p√®te" in voix:
                self.parler("Bienvenue sur la chaine Djamal Dev")
            else:
                try:
                    self.question_generale(voix)
                except:
                    try:
                        wikipedia.set_lang("fr")
                        info = wikipedia.summary(voix, 1)
                        self.parler(str(info))
                    except:
                        self.parler("Je n'ai pas bien compris")


if __name__ == "__main__":
    assistant = voxaAssistant()
    while True:
        assistant.voxa()


```

## Test du code

{{< video https://djamal2905.github.io/djamal_website/INFO_MINI_PROJETS/assistant.mp4 >}}

## Conclusion

Ce code met en place un assistant vocal capable de reconna√Ætre et d'ex√©cuter des commandes vocales en fran√ßais, d'effectuer des recherches sur le web, et de r√©pondre aux questions gr√¢ce √† Wolfram Alpha et Wikip√©dia. Il constitue une base quelque peu solide pour un assistant personnel plus ou moins intelligent.


[**T√©l√©charger le fichier .python**](https://djamal2905.github.io/djamal_website/INFO_MINI_PROJETS/chat.py)

[**T√©l√©charger la vid√©o**](https://djamal2905.github.io/djamal_website/INFO_MINI_PROJETS/assistant.mp4)

Si vous avez des questions, vous pouvez me contacter !!!

[Retour √† la page d'accueuil](https://djamal2905.github.io/djamal_website)